--- 
wordpress_id: 25
layout: post
title: Learning Erlang
wordpress_url: http://disnetdev.com/blog/2008/01/03/learning-erlang/
---
In my never ending quest to know more than is strictly necessary about this best of all possible worlds, I have recently taken to learning a new programming language: Erlang!<br /><br />Why learn a new language? Because different languages let you solve different problems. Because new languages expand your mind. Because new languages make you more marketable. Mostly though because it is fun! (my neurosis revealed at last!)<br /><br />I've been picking up Erlang with this <a href="http://www.amazon.com/Programming-Erlang-Software-Concurrent-World/dp/193435600X/ref=pd_bbs_sr_1?ie=UTF8&amp;s=books&amp;qid=1199345681&amp;sr=8-1">book</a> written by one of the creators of Erlang. I usually don't go for dead trees when learning new languages (online docs and tutorials have usually sufficed) but this one was well worth it. The author has a bunch of extended apps which do a great job of giving a feel for the flow of Erlang. <br /><br />Why Erlang? Because Erlang has been specifically designed to ease development of concurrent software. This is good because the one striking trend from the processor peeps is that the only thing guaranteed to increase in CPUs are the number of <a href="http://www.intel.com/technology/magazine/computing/multi-core-0705.pdf">cores</a>. Gone are the days of ever increasing clock speeds. It doesn't matter how long Intel expands it's <a href="http://en.wikipedia.org/wiki/Pentium_4">pipeline</a>, the clocks aren't going anywhere in a hurry. And so, we must start dealing with concurrent programming. <br /><br />Erlang deals with the concurrency problem firstly by being a functional programming language and has no side effects. This means that the biggest issue traditional languages face (dealing with shared memory) simply does not exist in Erlang. Secondly, Erlang has the concept of processes. Processes are like threads except extremely lightweight and managed by the Erlang system instead of the OS. This means that you can spawn thousands of processes extremely quickly. To give you an idea of how quickly, on my laptop I spawned 32,000 processes and the average time it took to spawn each was 2 microseconds.<br /><br />Here is a grab bag of interesting Erlang features. In an effort to lock in what I'm learning by writing (both code and "real" words) these may wind up being expanded into full on posts.<br /><ul><li>Functional language<br /></li><li>First class functions<br /></li><li>No side effects (mostly)<br /></li><li>Data Structures: Atoms, Tuples, Lists<br /></li><li>Lightweight processes (as opposed to say threads in Java)<br /></li><li>Simple communication between processes (Pid ! {Message})</li><li>Pattern matching<br /></li><li>List comprehensions [2*X || X &lt;- List]<br /></li><li>Mnesisa DBMS uses list comprehensions (select * from foo becomes [row || row &lt;- foo])</li><li>Hot swapping code</li><li>Fault tolerance<br /></li></ul><br /><br /><br /><br /><br /><br />
